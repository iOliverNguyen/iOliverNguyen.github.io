<!doctype html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Implement a Distributed State Machine with Redis to Migrate Billions of Records | Oliver Nguyen</title><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="robots" content="all,follow"><meta name="googlebot" content="index,follow,snippet,archive"><meta name="og:site_name" content="Oliver Nguyen"><meta property="og:title" content="Implement a Distributed State Machine with Redis to Migrate Billions of Records"><meta property="og:description" content="As a start-up company, we started with a simple architecture: All data were stored in a single centralized Postgres instance, shared by a few services. It has been working well and allows us to move fast, deliver features, enter the market, acquire clients, and grow exponentially.
Fast forward a couple of years, today we have thousands of clients and billions of records, it&rsquo;s time to migrate the top tables from Postgres to a better solution."><meta property="og:type" content="article"><meta property="og:url" content="https://iOliverNguyen.github.io/w/migrate/"><meta property="og:image" content="https://iOliverNguyen.github.io/images/ogx.png"><meta property="article:section" content="w"><meta property="article:published_time" content="2024-10-20T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-20T00:00:00+00:00"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://iOliverNguyen.github.io/images/ogx.png"><meta name="twitter:title" content="Implement a Distributed State Machine with Redis to Migrate Billions of Records"><meta name="twitter:description" content="As a start-up company, we started with a simple architecture: All data were stored in a single centralized Postgres instance, shared by a few services. It has been working well and allows us to move fast, deliver features, enter the market, acquire clients, and grow exponentially.
Fast forward a couple of years, today we have thousands of clients and billions of records, it&rsquo;s time to migrate the top tables from Postgres to a better solution."><link rel="stylesheet" href="https://iOliverNguyen.github.io/css/style-classic.css"><link rel="stylesheet" href="https://iOliverNguyen.github.io/style.css"><link rel="icon" type="image/png" href="/images/favicon.png"><link href="https://iOliverNguyen.github.io/w/migrate/index.xml" rel="alternate" type="application/rss+xml" title="Oliver Nguyen"><script async src="https://www.googletagmanager.com/gtag/js?id=G-L5X8RJDCLM"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-L5X8RJDCLM")</script><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></head><body class="max-width mx-auto px3 ltr"><div class="content index py4"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Implement a Distributed State Machine with Redis to Migrate Billions of Records</h1><div class="meta"><div class="postdate"><time datetime="2024-10-20 00:00:00 &#43;0000 UTC" itemprop="datePublished">2024-10-20</time></div><div class="article-tag">&nbsp;Â· <a class="tag-link" href="/w/#db" rel="tag">db</a></div><div class="published-at">published at <a target="_blank" href="https://blog.connectly.ai/implement-a-distributed-state-machine-with-redis-to-migrate-billions-of-records-9b135ab60773">Connectly.ai</a></div></div></header><div class="content" itemprop="articleBody"><p><em>As a start-up company, we started with a simple architecture: All data were stored in a single centralized Postgres instance, shared by a few services. It has been working well and allows us to move fast, deliver features, enter the market, acquire clients, and grow exponentially.</em></p><p><em>Fast forward a couple of years, today we have thousands of clients and billions of records, it&rsquo;s time to migrate the top tables from Postgres to a better solution. We choose DynamoDB, a key-value datastore by AWS, with high availability, low-latency performance, and see the queries reduce to single-digit milliseconds.</em></p><p><em>As with any decent migration plan, we carefully analyze usages, define schema and indexes, start with double-write, switch read queries to DynamoDB with fallback to Postgres, import all records to DynamoDB, and finally stop querying from Postgres.</em></p><p><em><strong>This article focuses on the step of importing records for the <code>room_events</code> table: Scan all the records of this table and write them to DynamoDB</strong>. The goal is to ensure a complete migration, with no events missed. The migration script must be fast, capable of running in parallel, and able to stop and resume from its last state. It should also be resilient, handling network errors or interruptions and resuming seamlessly.</em></p><p><em>Letâ€™s see how we can do this!</em> ðŸ¥¸</p><hr><h2 id="schema">Schema</h2><p>Here is the simplified schema of the <code>room_events</code> table in Postgres:</p><table><thead><tr><th>room_events</th><th></th><th></th></tr></thead><tbody><tr><td><code>id</code></td><td>ULID</td><td>primary key</td></tr><tr><td><code>room_id</code></td><td>UUID</td><td>references rooms.id</td></tr><tr><td><code>data</code></td><td>JSON</td><td></td></tr></tbody></table><ul><li>The <code>id</code> column is <a href="https://github.com/ulid/spec">ULID</a>, which has a time component.</li><li>It has billions of records.</li></ul><h2 id="a-naive-approach">A Naive Approach</h2><p>Let&rsquo;s write a simple version of the migration script: <em>Run in a single loop, scan all records, and write to DynamoDB</em>. Also, include a few trivial things to not have to worry about them later:</p><ul><li>Scan with cursor pagination based on the <code>id</code> column.</li><li>For each write, use a batch of max 25 records (<a href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html">the maximum number of items allowed by BatchWriteItem</a>).</li><li>Scan backward from the double-write date to the earliest date. So we have the most recent records available first.</li></ul><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;connectly.ai/go/pkgs/ulid&#34;</span>

<span class="kd">var</span> <span class="nx">startDate</span> <span class="p">=</span> <span class="nf">parseTime</span><span class="p">(</span><span class="s">&#34;2020-01-01T00:00:00Z&#34;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">endDate</span>   <span class="p">=</span> <span class="nf">parseTime</span><span class="p">(</span><span class="s">&#34;2024-10-20T00:00:00Z&#34;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">pgBatchSize</span>  <span class="p">=</span> <span class="mi">1000</span>
<span class="kd">var</span> <span class="nx">dynBatchSize</span> <span class="p">=</span> <span class="mi">25</span>

<span class="kd">type</span> <span class="nx">Migrator</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">logger</span>
    <span class="nx">pg</span>  <span class="nx">PostgresClient</span>
    <span class="nx">dyn</span> <span class="nx">DynamoClient</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">QueryRoomEventsRequest</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">BeforeID</span> <span class="nx">ulid</span><span class="p">.</span><span class="nx">ULID</span>
    <span class="nx">Limit</span>    <span class="kt">int</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">QueryRoomEventsResponse</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Items</span>  <span class="p">[]</span><span class="nx">RoomEvents</span>
    <span class="nx">lastID</span> <span class="nx">ulid</span><span class="p">.</span><span class="nx">ULID</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">Migrate</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">lastID</span><span class="p">,</span> <span class="nx">count</span> <span class="o">:=</span> <span class="nx">ulid</span><span class="p">.</span><span class="nf">FromTime</span><span class="p">(</span><span class="nx">endDate</span><span class="p">),</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">req</span> <span class="o">:=</span> <span class="nx">QueryRoomEventsRequest</span><span class="p">{</span>
            <span class="nx">BeforeID</span><span class="p">:</span> <span class="nx">lastID</span><span class="p">,</span>
            <span class="nx">Limit</span><span class="p">:</span>    <span class="nx">pgBatchSize</span>
        <span class="p">}</span>
        <span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">queryRoomEvents</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
        <span class="nx">m</span><span class="p">.</span><span class="nf">Logger</span><span class="p">(</span><span class="nx">ctx</span><span class="p">).</span><span class="nf">Must</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;failed to query room events&#34;</span><span class="p">)</span>

        <span class="nx">count</span> <span class="o">+=</span> <span class="nx">res</span><span class="p">.</span><span class="nx">Items</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">Items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">m</span><span class="p">.</span><span class="nf">Logger</span><span class="p">(</span><span class="nx">ctx</span><span class="p">).</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;MIGRATION DONE: count=%v&#34;</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">Items</span><span class="p">);</span> <span class="nx">i</span> <span class="o">+=</span> <span class="nx">dynBatchSize</span> <span class="p">{</span>
            <span class="nx">j</span> <span class="o">:=</span> <span class="nf">min</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">dynBatchSize</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">Items</span><span class="p">))</span>
            <span class="nx">batch</span> <span class="o">:=</span> <span class="nx">res</span><span class="p">.</span><span class="nx">Items</span><span class="p">[</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">]</span>
            <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">batchWriteDynamo</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">batch</span><span class="p">)</span>
            <span class="nx">m</span><span class="p">.</span><span class="nf">Logger</span><span class="p">(</span><span class="nx">ctx</span><span class="p">).</span><span class="nf">Must</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;failed to write to dynamodb&#34;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">queryRoomEvents</span><span class="p">(</span> <span class="cm">/* ... */</span> <span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">batchWriteDynamo</span><span class="p">(</span><span class="cm">/* ... */</span> <span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</code></pre></div><hr><h2 id="real-world-approach">Real-World Approach</h2><p>This naive script will operate under some assumptions:</p><ul><li>Calls to <code>queryRoomEvents()</code> and <code>batchWriteDynamo()</code> always success.</li><li>The number of records is small enough, to complete in a single run on a single machine.</li></ul><p>However, in the real world, we can not rely on those assumptions:</p><ul><li>Requests may timeout or fail randomly.</li><li>Databases may reach its throughput or connection limits.</li><li>Pods may get restarted due to failures or new deployments.</li><li>Huge amount of records may make the single-thread approach impractical, taking ages to complete.</li></ul><p>To handle these challenges, we need to improve our script and implement a more robust, distributed solution:</p><p><strong>Data Splitting and Partitioning:</strong></p><ul><li>Split the data by grouping room events into 1-hour <code>Timeslot</code>. Each slot should represent a manageable unit of work that is processed independently. This allows for better load balancing and improved parallelism.</li></ul><p><strong>Parallel Processing with Multiple Workers:</strong></p><ul><li>Run multiple workers across multiple pods, with each pod managing multiple goroutines.</li><li>Each worker will pick a <code>Timeslot</code>, migrate it, and then move on to the next available slot, ensuring that all workers operate concurrently.</li></ul><p><strong>States Management in Redis</strong>:</p><ul><li>Workers will acquire a lock for each <code>Timeslot</code> in Redis before processing process it, to ensure that only a single worker can handle a slot at a time.</li><li>After processing a <code>Timeslot</code>, the worker will update the slot&rsquo;s status to <code>FINISHED</code>.</li><li>If a worker fail, the lock will be released or expired, allowing another worker to take over and continue processing.</li></ul><p><strong>Keeper for Centralized Progress Tracking:</strong></p><ul><li>Introduce a <code>Keeper</code> to monitor the progress of all workers, maintain a global overview of the migration, and log the global progress.</li><li>It will keep track of the progress and status of each <code>Timeslot</code>, ensure that no slot is missed.</li></ul><p><strong>Timeout Handling and Retry Mechanism</strong>:</p><ul><li>Implement a retry mechanism with exponential backoff for both PostgreSQL reads and DynamoDB writes, making the script resilient to transient network failures or timeouts.</li><li>And another layer of retry and error handling to prevent any panic or unexpected failure, ensuring that the script can gracefully recover, with no data loss or corrupted states.</li></ul><p><strong>Data Verification:</strong></p><ul><li>After the migration, run a verification script to ensure that all room events have been successfully migrated, with no missing records.</li><li>The verification process should compare the record count and sample data between PostgreSQL and DynamoDB.</li></ul><p><strong>Leveraging Idempotency in Writes:</strong></p><p>Another important point is that the write step for each record is idempotent. This means that writing the same record to DynamoDB multiple times will simply overwrite the previous version, ensuring no duplicates.</p><p>We can use this to our advantage:</p><ul><li>If bugs are found in the script and a new version needs to be run, we can reset all states and start from scratch without deleting existing data in DynamoDB.</li><li>If the script stops for any reason and resumes later, it might overwrite a few records in DynamoDB. This is acceptable, as occasional re-writes are harmless and prevent the need to redo large portions of already completed work.</li></ul><hr><h2 id="architecture">Architecture</h2><p>With those concepts in mind, let&rsquo;s start thinking about the architecture.</p><h3 id="store-states-in-redis">Store States in Redis</h3><p>Given that we already split the records into <code>Timeslot</code>s, each consists of all room events for one hour. We need to keep track of the progress of these slots in Redis:</p><ul><li>Prefix all keys with <code>mgre:</code> â†’ to be able to scan and delete all of them.</li><li><code>mgre:status</code> â†’ the global migration status: <code>NOT_STARTED</code>, <code>TO_START</code>, <code>IN_PROGRESS</code>, <code>TO_STOP</code>, <code>STOPPED</code>, <code>FINISHED</code>.</li><li><code>mgre:{TIMESLOT}:worker</code> â†’ the current worker working on the slot, an exclusive lock with short TTL (for example 15-30 sec). When a worker fails to release the lock, it will automatically expire so another worker can take over later.</li><li><code>mgre:{TIMESLOT}:states</code> â†’ a JSON storing states of the slot, with long TTL (for example, 1 week) and properties:<ul><li><code>.status</code> â†’ empty, <code>IN_PROGRESS</code> or <code>FINISHED</code>. Note that there is no <code>ERROR</code> status. <strong>All room events and all slots must be migrated successfully!</strong> ðŸ˜Ž</li><li><code>.last_id</code> â†’ the last migrated room events id, to be able to resume the progress.</li></ul></li></ul><p>So we need 2 keys for each slot. Multiply with 3 years of data, there will be 52.560 keys (3 * 365 * 24 * 2). That&rsquo;s a lot!</p><p>We can optimize the Redis keys by cleaning the group of consecutive <code>FINISHED</code> slots and replacing them with a single <code>mgre:last_slot</code> key. This way, we only need to keep track of a small amount of keys. Of course, this is based on the assumption that the slots have a similar number of room events, so each worker can take a similar amount of time to finish.</p><h3 id="manager-keepers-and-workers">Manager, Keepers, and Workers</h3><p>The script runs in multiple pods. Each pod consists of a <code>Manager</code>, a <code>Keeper</code>, and multiple <code>Worker</code>s. Each run in its own goroutine.</p><p><strong>A <code>Manager</code> manages all workers in a pod:</strong></p><ul><li>Each pod has a single <code>Manager</code>.</li><li>It loops through all the <code>Timeslot</code>s.</li><li>For each slot, it verifies the corresponding status and lock in Redis by checking <code>mgre:{TIMESLOT}:states</code> and <code>mgre:{TIMESLOT}:worker</code>.</li><li>Then dispatch the slot to workers by sending it to a Go channel <code>slotCh</code>.</li></ul><p><strong>A <code>Worker</code> migrate room events by each <code>Timeslot</code>:</strong></p><ul><li>There are multiple workers, each running in a separate goroutine.</li><li>A worker receives <code>Timeslot</code>s from the channel <code>slotCh</code>, one at a time.</li><li>It verifies the status in <code>mgre:{TIMESLOT}:states</code> again.</li><li>And acquire the lock by a <code>SET NX</code> command on <code>mgre:{TIMESLOT}:worker</code>.</li><li>If all success, it will start working on the slot.</li><li>It will occasionally save the progress by updating <code>mgre:{TIMESLOT}:states</code>.</li><li>And should be able to resume from the saved progress.</li><li>If it fails, the lock will eventually expire and another worker can take over.</li></ul><p><strong>A <code>Keeper</code> overview the whole migration progress:</strong></p><ul><li>There should be only one active <code>Keeper</code> for all pods.</li><li>We should have a lock <code>mgre:keeper</code> with short TTL, so if a <code>Keeper</code> from a pod fails, another <code>Keeper</code> can take over.</li><li>A failed <code>Keeper</code> will return to stand-by state, and continue monitoring the lock to see if it can become active again.</li><li>Every few sec, the active Keeper scan from <code>mgre:last_slot</code> to find consequent FINISHED <code>Timelot</code>s. It will then mark <code>mgre:last_slot</code> at the latest consequent FINISHED slot, and clean them.</li><li>When all remaining slots are FINISHED, it marks the global <code>mgre:status</code> as FINISHED. All the managers look at that status and will then stop.</li></ul><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">runManager</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ... recover, logs, metrics ...
</span><span class="c1"></span>    <span class="c1">// ... loop and call runManagerStep (more on this later) ...
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">runManagerStep</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="nx">Status</span> <span class="p">{</span>
    <span class="c1">// ... recover, logs, metrics ...
</span><span class="c1"></span>    
    <span class="k">for</span> <span class="p">{</span>
        <span class="nf">mustRefresh</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">globalStatus</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">lastSlot</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">globalStatus</span><span class="p">.</span><span class="nf">Load</span><span class="p">().</span><span class="nf">Is</span><span class="p">(</span><span class="nx">SKIPPED</span><span class="p">,</span> <span class="nx">FINISHED</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="cm">/*...*/</span> <span class="p">}</span>
        
        <span class="k">for</span> <span class="nx">slot</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">lastSlot</span><span class="p">.</span><span class="nf">Load</span><span class="p">();</span> <span class="nx">slot</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">endSlot</span><span class="p">);</span> <span class="nx">slot</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">slotStates</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">getSlotStates</span><span class="p">(</span><span class="nx">slot</span><span class="p">)</span>
            <span class="nf">mustRefresh</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">slotStates</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">slotStates</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nf">Load</span><span class="p">().</span><span class="nf">Is</span><span class="p">(</span><span class="nx">SKIPPED</span><span class="p">,</span> <span class="nx">FINISHED</span><span class="p">)</span> <span class="p">{</span> <span class="k">continue</span> <span class="p">}</span>
            
            <span class="nx">slotWorkerID</span> <span class="o">:=</span> <span class="nf">mustAcquireLock</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">slot</span><span class="p">.</span><span class="nx">Worker</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">!</span><span class="nx">slotWorkerID</span><span class="p">.</span><span class="nf">Load</span><span class="p">().</span><span class="nf">IsPod</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">PodID</span><span class="p">)</span> <span class="p">{</span> <span class="k">continue</span> <span class="p">}</span>

            <span class="k">select</span> <span class="p">{</span>
                <span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
                    <span class="k">return</span> <span class="nx">IN_PROGRESS</span>  <span class="c1">// ðŸ‘ˆ stop when the pod stops
</span><span class="c1"></span>                <span class="k">case</span> <span class="nx">m</span><span class="p">.</span><span class="nx">slotCh</span> <span class="o">&lt;-</span> <span class="nx">slot</span><span class="p">:</span> 
                    <span class="k">continue</span>            <span class="c1">// ðŸ‘ˆ send to slot channel
</span><span class="c1"></span>            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// ðŸ‘‡ still IN_PROGRESS, only Keeper can verify all slots are FINISHED
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">IN_PROGRESS</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">runWorker</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ... recover, logs, metrics ...
</span><span class="c1"></span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
                <span class="k">return</span>
            <span class="k">case</span> <span class="nx">slot</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">m</span><span class="p">.</span><span class="nx">slotCh</span>
                <span class="nx">s</span><span class="p">.</span><span class="nf">runTimeslot</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">slot</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">runTimeslot</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">slot</span> <span class="nx">Timeslot</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ... recover, logs, metrics ...
</span><span class="c1"></span>
    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
                <span class="k">return</span>
            <span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">t</span><span class="p">.</span><span class="nx">C</span>
                <span class="nx">status</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">runTimeslotStep</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">slot</span><span class="p">)</span>
                <span class="k">if</span> <span class="nx">status</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="nx">SKIPPED</span><span class="p">,</span> <span class="nx">FINISHED</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
                <span class="nx">t</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">runTimeslotStep</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">slot</span> <span class="nx">Timeslot</span><span class="p">)</span> <span class="nx">Status</span> <span class="p">{</span>
    <span class="c1">// ... recover, logs, metrics ...
</span><span class="c1"></span>
    <span class="nx">st</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">getSlotStates</span><span class="p">(</span><span class="nx">slot</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// ðŸ‘‡ refresh the states
</span><span class="c1"></span>        <span class="nf">mustRefresh</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">States</span><span class="p">)</span>
        <span class="c1">// ðŸ‘‡ verify the status, return if already FINISHED
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">st</span><span class="p">.</span><span class="nx">States</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nf">Load</span><span class="p">().</span><span class="nf">Is</span><span class="p">(</span><span class="nx">FINISHED</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">FINISHED</span> <span class="p">}</span>
        <span class="c1">// ðŸ‘‡ another worker is working on the slot, SKIPPED
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nf">mustAcquireLock</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Worker</span><span class="p">,</span> <span class="nx">workerID</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">SKIPPED</span> <span class="p">}</span>

        <span class="nx">lastID</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">States</span><span class="p">.</span><span class="nx">LastID</span>
        <span class="k">for</span> <span class="nx">lastID</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">startID</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">req</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">QueryRoomEventsRequest</span><span class="p">{</span> <span class="nx">BeforeID</span><span class="p">:</span> <span class="nx">lastID</span><span class="p">;</span> <span class="nx">Limit</span><span class="p">:</span> <span class="o">...</span> <span class="p">}</span>
            <span class="nx">res</span> <span class="o">:=</span> <span class="nf">mustRetry</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">strategy</span><span class="p">,</span> <span class="nf">msgf</span><span class="p">(</span><span class="s">&#34;query room events&#34;</span><span class="p">),</span> 
                <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="nx">QueryRoomEventsResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span> 
                    <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nf">queryRoomEvents</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="c1">// ðŸ‘‰ ... save to DynamoDB
</span><span class="c1"></span>            <span class="c1">// ðŸ‘‰ ... save progress to Redis
</span><span class="c1"></span>            <span class="nx">lastID</span> <span class="p">=</span> <span class="nx">res</span><span class="p">.</span><span class="nx">LastID</span>
        <span class="p">}</span> 
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">runKeeper</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ... recover, logs, metrics ...
</span><span class="c1"></span>    <span class="c1">// ... loop and call runKeeperStep (more on this later) ...
</span><span class="c1"></span><span class="p">}</span>
							 
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">runKeeperStep</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="nx">Status</span> <span class="p">{</span>
    <span class="c1">// ... recover, logs, metrics ...
</span><span class="c1"></span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// ðŸ‘‡ acquire lock and refresh states
</span><span class="c1"></span>        <span class="c1">//    only a single active Keeper across all pods
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nf">mustAcquireLock</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">keeper</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">SKIPPED</span> <span class="p">}</span>
        <span class="nf">mustRefresh</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">globalStatus</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">lastSlot</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">globalStatus</span><span class="p">.</span><span class="nf">Load</span><span class="p">().</span><span class="nf">Is</span><span class="p">(</span><span class="nx">FINISHED</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">FINISHED</span> <span class="p">}</span>

        <span class="c1">// ðŸ‘‡ find the last consecutive FINISHED slot
</span><span class="c1"></span>        <span class="nx">newLastSlot</span> <span class="o">:=</span> <span class="nx">states</span><span class="p">.</span><span class="nx">LastSlot</span>
        <span class="k">for</span> <span class="nx">slot</span> <span class="o">:=</span> <span class="nx">states</span><span class="p">.</span><span class="nx">LastSlot</span><span class="p">;</span> <span class="nx">slot</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">endSlot</span><span class="p">);</span> <span class="nx">slot</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">slotStates</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">getSlotStates</span><span class="p">(</span><span class="nx">slot</span><span class="p">)</span>
            <span class="nx">err</span> <span class="o">:=</span> <span class="nf">tryRefresh</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">slotStates</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
            <span class="k">if</span> <span class="p">!</span><span class="nx">slotStates</span><span class="p">.</span><span class="nx">Status</span><span class="p">.</span><span class="nf">Load</span><span class="p">().</span><span class="nf">Is</span><span class="p">(</span><span class="nx">FINISHED</span><span class="p">)</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
            
            <span class="nx">newLastSlot</span> <span class="p">=</span> <span class="nx">slot</span>
            <span class="nf">tryClean</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">slotStates</span><span class="p">)</span> <span class="c1">// ðŸ‘ˆ clean FINISHED slot
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="c1">// ðŸ‘‡ save the mgre:last_slot state
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">newLastSlot</span> <span class="o">!=</span> <span class="nx">states</span><span class="p">.</span><span class="nx">LastSlot</span> <span class="p">{</span>
            <span class="nf">mustUpdate</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">lastSlot</span><span class="p">,</span> <span class="nx">newLastSlot</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="retry-mechanism">Retry Mechanism</h3><p>The plan looks good, right? No, not yet. What happens if any of the above steps fail?</p><p><strong>Each <code>Manager</code>, <code>Worker</code>, <code>Keeper</code> run in a goroutine and always retry itself:</strong></p><ul><li>Always have <code>recover()</code>, because any non-recover panic in a goroutine can stop the whole process.</li><li>There are 2 main loops to able to restart whenever there is problem:<ul><li>The outer loop is responsible for restarting the inner loop. It only contains simple statements to ensure that it will never panic.</li><li>The inner loop is responsible for handling the logic: load states, query data, etc.</li></ul></li><li>For <code>Worker</code>, there is one extra outermost loop to receive slots and pass them to outer loop then inner loop to get executed.</li><li>And a <code>retry</code> function to execute and retry every query a few more times.</li></ul><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">initAndRun</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nx">m</span><span class="p">.</span><span class="nf">runManager</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">m</span><span class="p">.</span><span class="nf">runKeeper</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">numWorkers</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">m</span><span class="p">.</span><span class="nf">runWorker</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">runWorker</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="nf">log</span><span class="p">(</span><span class="nx">ctx</span><span class="p">).</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;panic in the outermost layer, will stop&#34;</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// ðŸ‘‡ the outermost loop to receive the next slot
</span><span class="c1"></span>    <span class="c1">//    it only contains simple statements to ensure that it never panics
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
                <span class="k">return</span>
            <span class="k">case</span> <span class="nx">slot</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">m</span><span class="p">.</span><span class="nx">slotCh</span>  <span class="c1">// ðŸ‘ˆ receive slots from channel
</span><span class="c1"></span>                <span class="nx">s</span><span class="p">.</span><span class="nf">runTimeslot</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">slot</span><span class="p">)</span> <span class="c1">// and execute them one by one
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">runTimeslot</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="nf">log</span><span class="p">(</span><span class="nx">ctx</span><span class="p">).</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;panic in the outer layer, will stop&#34;</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// ðŸ‘‡ the outer loop to retry the migration logic
</span><span class="c1"></span>    <span class="c1">//    it only contains simple statements to ensure that it never panics
</span><span class="c1"></span>    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span> 
                <span class="k">return</span>                <span class="c1">// ðŸ‘ˆ stop when the pod stops
</span><span class="c1"></span>            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">t</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
                <span class="nx">status</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">runTimeslotStep</span><span class="p">()</span>
                <span class="k">if</span> <span class="nx">status</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="nx">FINISHED</span><span class="p">,</span> <span class="nx">SKIPPED</span><span class="p">)</span> <span class="p">{</span> 
                    <span class="k">return</span>            <span class="c1">// ðŸ‘ˆ stop when FINISHED or SKIPPED
</span><span class="c1"></span>                <span class="p">}</span>
                <span class="nx">t</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="c1">// ðŸ‘ˆ retry after a few sec
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">runTimeslotStep</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">Status</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="nf">logger</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;panic in the inner layer, will retry&#34;</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ðŸ‘‡ the inner loop to execute the migration logic
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// ... load states, progress, acquire lock...
</span><span class="c1"></span>
        <span class="c1">// ðŸ‘‡ query database
</span><span class="c1"></span>        <span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">retry</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">strategy</span><span class="p">,</span> <span class="nf">msgf</span><span class="p">(</span><span class="s">&#34;query room events&#34;</span><span class="p">),</span> 
            <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="nx">QueryRoomEventsResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nf">queryRoomEvents</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
            <span class="p">})</span>
        <span class="c1">// ðŸ‘‡ even if there is panic, the runManagerStep will recover, stop
</span><span class="c1"></span>        <span class="c1">//    and the outer loop (runManager) will continue retry after few sec
</span><span class="c1"></span>        <span class="nf">must</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        
        <span class="c1">// ... save states, progress, refresh lock
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="c1">// ... save status as FINISHED
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">FINISHED</span> <span class="c1">// ðŸ‘ˆ tell the outer loop to stop
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>When any error happens, for example, network timeout:</p><ul><li>The <code>retry</code> function will retry a few times.</li><li>If it fails, the inner loop will stop and give control back to the outer loop.</li><li>The outer loop now waits for a few secs and start inner loop again.</li><li>The inner loop then loads the previous states, progress, acquires lock, and continues.</li></ul><p>This ensure that the code always run until all records are migrated, or the pod restarts. In the later case, it will resume the migration progress next time.</p><h3 id="other-notes">Other Notes</h3><p><strong>API to control the migration:</strong></p><ul><li>We should expose an API to control the migration: start and stop all managers, keepers, workers from all pods.</li><li>When receive START command, the API set <code>mgre:status</code> to <code>TO_START</code> or <code>IN_PROGRESS</code>.</li><li>When managers from all pods see the status, they will start or resume the migration.</li></ul><p><strong>Stop all using <code>context.WithCancel()</code>:</strong></p><ul><li>Use a single <code>context.Context</code> and pass it to all manager, keeper, and workers in the same pod.</li><li>When managers see the status change to <code>TO_STOP</code>, <code>STOPPED</code>, they will cancel the context, make keeper and all workers stop gracefully.</li></ul><p><strong>Save progress as states and refresh the lock periodically:</strong></p><ul><li>While each worker or keeper is working on its stuff, it should save the progress into Redis, and refresh the lock, to be able to resume later and prevent other workers from taking the slot.</li></ul><p><strong><code>Manager</code> periodically check the <code>mgre:last_slot</code> in Redis:</strong></p><ul><li>Even if the slot is already taken by a worker, there is chance that the worker stops and the slot is not FINISHED.</li><li>While each <code>Manager</code> loops through all the slots, after a while, it needs to restart the loop and check the <code>mgre:last_slot</code> status in Redis, then resume from there. It&rsquo;s to ensure that we won&rsquo;t leave any slots unfinished.</li></ul><p><strong>Log and report the progress:</strong></p><ul><li>The <code>Keeper</code> is responsible to overview the progress, clean up finished records, and update <code>mgre:last_slot</code>.</li><li>During the job, the <code>Keeper</code> should periodically log and report progress to provide visibility into the migration status and allow real-time tracking of overall progress.</li></ul><p><strong>Monitor the resources and rate limit:</strong></p><ul><li>The migration may cost all resources on the database. We may want to monitor and add rate limit, fine tune parameters when necessary, to ensure everything go as smooth as possible.</li></ul><hr><h2 id="implementation">Implementation</h2><h3 id="timeslot">Timeslot</h3><p>Each <code>Timeslot</code> represents all room events in one hour. We can implement it as a <code>time.Time</code> and store it in Redis as a string with the format <code>20241020.02</code>.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Timeslot</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="p">}</span>

<span class="kd">const</span> <span class="nx">slotDuration</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span>

<span class="kd">func</span> <span class="nf">newTimeSlot</span><span class="p">(</span><span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="nx">Timeslot</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="p">{</span>	<span class="k">return</span> <span class="nx">Timeslot</span><span class="p">{</span><span class="nx">t</span><span class="p">}</span> <span class="p">}</span>
    <span class="c1">// ðŸ‘‰ each slot is an hour
</span><span class="c1"></span>    <span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">In</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">UTC</span><span class="p">).</span><span class="nf">Truncate</span><span class="p">(</span><span class="nx">kSlotDuration</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">Timeslot</span><span class="p">{</span><span class="nx">t</span><span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">Timeslot</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>  
    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Time</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;&#34;</span> <span class="p">}</span>  
    <span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Time</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="s">&#34;20060102.15&#34;</span><span class="p">)</span>  
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">Timeslot</span><span class="p">)</span> <span class="nf">Range</span><span class="p">()</span> <span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="nx">ulid</span><span class="p">.</span><span class="nx">ULID</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">ulid</span><span class="p">.</span><span class="nf">FromTime</span><span class="p">(</span><span class="nx">t</span><span class="p">),</span> <span class="nx">ulid</span><span class="p">.</span><span class="nf">FromTime</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">Timeslot</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Timeslot</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Timeslot</span><span class="p">{</span><span class="nx">t</span><span class="p">.</span><span class="nx">Time</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">slotDuration</span><span class="p">)}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">Timeslot</span><span class="p">)</span> <span class="nf">Next</span><span class="p">()</span> <span class="nx">Timeslot</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// ðŸ‘ˆ we are going from latest to earliest
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">Timeslot</span><span class="p">)</span> <span class="nf">Sub</span><span class="p">(</span><span class="nx">x</span> <span class="nx">Timeslot</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Timeslot</span><span class="p">{</span><span class="nx">t</span><span class="p">.</span><span class="nx">Time</span><span class="p">.</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">kSlotDuration</span><span class="p">)}</span>
<span class="p">}</span>
</code></pre></div><h3 id="retry-queries">Retry() Queries</h3><p>As <a href="#retry-mechanism">discussed before</a>, we have 2 loops to handle panic, retry, and resume states. So for this <code>retry()</code> function, we only need to retry the query a couple of times, to be able to tolerate some network failures:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ðŸ‘‰ this will retry 3 times
</span><span class="c1"></span><span class="nx">strategy</span> <span class="o">:=</span> <span class="nf">NewSimpleStrategy</span><span class="p">(</span>
    <span class="mi">100</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">,</span> <span class="mi">200</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">,</span> <span class="mi">500</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>

<span class="c1">// ðŸ‘‰ call the QueryRoomEvents with retry-ability
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">retry</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">strategy</span><span class="p">,</span> <span class="nf">msgf</span><span class="p">(</span><span class="s">&#34;query database&#34;</span><span class="p">),</span>
    <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="nx">QueryRoomEventsRequest</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nf">QueryRoomEvents</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
    <span class="p">})</span>

<span class="c1">// ðŸ‘‰ if all retries failed, stop, and give control back to outer loop
</span><span class="c1">//    to try again after a few sec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mustRetry</span><span class="p">(</span> <span class="cm">/* ... */</span> <span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</code></pre></div><p>We can implement a simple retry logic:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">retry</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span>
    <span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">strategy</span> <span class="nx">RetryStrategy</span><span class="p">,</span>
    <span class="nx">msg</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span><span class="p">,</span> <span class="nx">fn</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="kt">error</span><span class="p">),</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="nx">count</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">x</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">fn</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">err</span> <span class="p">}</span>
        <span class="k">if</span> <span class="nx">next</span> <span class="o">:=</span> <span class="nx">strategy</span><span class="p">.</span><span class="nf">Next</span><span class="p">();</span> <span class="nx">next</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nf">logger</span><span class="p">(</span><span class="nx">ctx</span><span class="p">).</span><span class="nf">Warnf</span><span class="p">(</span><span class="s">&#34;failed to %v (attempt %v)&#34;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span>
            <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">next</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">logger</span><span class="p">(</span><span class="nx">ctx</span><span class="p">).</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed to %v (attempt %v)&#34;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span>
            <span class="k">return</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">err</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>An example implementation of retry strategy, which each retry happens after a pre-defined duration:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RetryStrategy</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">RetryStrategy</span><span class="p">)</span> <span class="nf">Next</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">f</span><span class="p">()</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewSimpleStrategy</span><span class="p">(</span><span class="nx">at</span> <span class="p">[]</span><span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="nx">RetryStrategy</span> <span class="p">{</span>
    <span class="nx">i</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
        <span class="nx">i</span><span class="o">++</span>
        <span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">at</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">i</span> <span class="p">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// no more retry
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>And implementation of <code>msgf()</code> func which can be used to quickly return a <code>fmt.Stringer</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StringFunc</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">StringFunc</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">f</span><span class="p">()</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">msgf</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="nx">any</span><span class="p">)</span> <span class="nx">StringFunc</span> <span class="p">{</span>
   <span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
       <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="nx">msg</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="states">States</h3><p>There are many states: global status, global progress, slot status, slot progress, locks, etc. For each state, we need to refresh, update, or delete. Each action also needs to be able to retry:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">globalStatus</span> <span class="o">:=</span> <span class="nf">mustRetry</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">strategy</span><span class="p">,</span> <span class="nf">msgf</span><span class="p">(</span><span class="s">&#34;load status&#34;</span><span class="p">)</span>
	<span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="nx">Status</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	    <span class="nx">str</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">redisClient</span><span class="p">.</span><span class="nf">GetString</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;mgre:status&#34;</span><span class="p">)</span>
	    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span> <span class="p">}</span>
	    <span class="k">if</span> <span class="nx">str</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">NOT_STARTED</span> <span class="p">}</span>
	    <span class="k">return</span> <span class="nf">parseStatus</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
	<span class="p">})</span>
<span class="nx">slotWorker</span> <span class="o">:=</span> <span class="nf">mustRetry</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">strategy</span><span class="p">,</span> <span class="nf">msgf</span><span class="p">(</span><span class="s">&#34;load last slot&#34;</span><span class="p">)</span>
	<span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">redisClient</span><span class="p">.</span><span class="nf">GetString</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;mgre:&#34;</span><span class="p">,</span> <span class="nf">kSlotWorker</span><span class="p">(</span><span class="nx">slot</span><span class="p">))</span>
	<span class="p">})</span>	
<span class="nf">mustRetry</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">strategy</span><span class="p">,</span> <span class="nf">msg</span><span class="p">(</span><span class="s">&#34;save status&#34;</span><span class="p">)</span>
	<span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	    <span class="nx">str</span> <span class="o">:=</span> <span class="nf">encodeStatus</span><span class="p">(</span><span class="nx">newStatus</span><span class="p">)</span>
	    <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">redisClient</span><span class="p">.</span><span class="nf">SetStringTTL</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;mgre:status&#34;</span><span class="p">,</span> <span class="nx">str</span><span class="p">)</span>
	    <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">})</span>

<span class="kd">func</span> <span class="nf">kSlotWorker</span><span class="p">(</span><span class="nx">slot</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;mgre:%v:worker&#34;</span><span class="p">,</span> <span class="nx">slot</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>The code will quickly become too verbose. We can encapsulate the key, including encoding logic, and other configs, in a <code>State</code> struct:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">State</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">v</span>      <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span>
    <span class="nx">key</span>    <span class="kt">string</span>
    <span class="nx">ttl</span>    <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
    <span class="nx">retry</span>  <span class="nx">RetryStrategy</span>
    <span class="nx">parse</span>  <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nx">encode</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewState</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span>
    <span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ttl</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="nx">strategy</span> <span class="nx">RetryStrategy</span><span class="p">,</span>
    <span class="nx">parse</span>  <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="kt">error</span><span class="p">),</span> 
    <span class="nx">encode</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> 
<span class="p">)</span> <span class="o">*</span><span class="nx">State</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">zero</span> <span class="nx">T</span>
    <span class="nx">st</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">State</span><span class="p">[</span><span class="nx">T</span><span class="p">]{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
    <span class="nx">st</span><span class="p">.</span><span class="nx">v</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">zero</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">st</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">State</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Load</span><span class="p">()</span> <span class="nx">T</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">v</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">T</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">State</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Refresh</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">redis</span> <span class="nx">RedisClient</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">str</span><span class="p">,</span> <span class="nx">err</span><span class="o">:=</span> <span class="nf">retry</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nf">msgf</span><span class="p">(</span><span class="s">&#34;get key %q&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">key</span><span class="p">),</span>
        <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">redisClient</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">err</span> <span class="p">}</span>
    <span class="nx">v</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">encode</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">err</span> <span class="p">}</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">v</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">State</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Save</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">redis</span> <span class="nx">RedisClient</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">str</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">err</span> <span class="p">}</span>
    <span class="k">return</span> <span class="nf">retry</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nf">msgf</span><span class="p">(</span><span class="s">&#34;set key %q&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">key</span><span class="p">),</span> 
        <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">redisClient</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">str</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ttl</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
        <span class="p">})</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">State</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">AcquireLock</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">redis</span> <span class="nx">RedisClient</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// ðŸ‘‰ similar to Save(), use SetNX instead ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>Then implement a few helpers to quickly access them:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">DepsI</span>  <span class="kd">interface</span> <span class="p">{</span> <span class="nf">_redis</span><span class="p">()</span> <span class="nx">RedisClient</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">StateI</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">_key</span><span class="p">()</span> <span class="kt">string</span><span class="p">;</span> <span class="nf">_ttl</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">;</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">mustRefresh</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">deps</span> <span class="nx">DepsI</span><span class="p">,</span> <span class="nx">states</span> <span class="nx">StateI</span><span class="p">,</span> <span class="nx">msg</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">mustSet</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">deps</span> <span class="nx">DepsI</span><span class="p">,</span> <span class="nx">state</span> <span class="nx">State</span><span class="p">[</span><span class="nx">T</span><span class="p">],</span> <span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>
</code></pre></div><p>Finally, we can simplify the usage:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">exampleInit</span><span class="p">(</span><span class="nx">slot</span> <span class="nx">Slot</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">globalStatus</span> <span class="p">=</span> <span class="nf">NewState</span><span class="p">(</span><span class="nx">kStatus</span><span class="p">,</span> <span class="nx">longTTL</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">strategy</span><span class="p">,</span> <span class="nx">parseStatus</span><span class="p">,</span> <span class="nx">encodeStatus</span><span class="p">)</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">slotWorker</span> <span class="p">=</span> <span class="nf">NewState</span><span class="p">(</span><span class="nf">kSlotWorker</span><span class="p">(</span><span class="nx">slot</span><span class="p">),</span> <span class="nx">shortTTL</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">strategy</span><span class="p">,</span> <span class="nx">parseStr</span><span class="p">,</span> <span class="nx">encodeStr</span><span class="p">)</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">exampleRefreshStates</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">mustRefresh</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="p">[]</span><span class="nx">StateI</span><span class="p">{</span><span class="nx">m</span><span class="p">.</span><span class="nx">globalStatus</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">lastSlot</span><span class="p">},</span> <span class="nf">msgf</span><span class="p">(</span><span class="s">&#34;load states&#34;</span><span class="p">))</span>
    <span class="nf">mustSet</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">globalStatus</span><span class="p">,</span> <span class="nx">FINISHED</span><span class="p">,</span> <span class="nf">msgf</span><span class="p">(</span><span class="s">&#34;save status&#34;</span><span class="p">))</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>That&rsquo;s much better!</p><h3 id="slotstates">SlotStates</h3><p>The <a href="#timeslot"><code>Timeslot</code> struct</a> only contains definition for time slot. We need another struct to encapsulate its states:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SlotStates</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Timeslot</span>             <span class="c1">// ðŸ‘‰ embedded Timeslot to quickly access methods
</span><span class="c1"></span>    <span class="nx">status</span> <span class="nx">State</span><span class="p">[</span><span class="nx">Status</span><span class="p">]</span> <span class="c1">// ðŸ‘‰ mgre:TIMESLOT:status
</span><span class="c1"></span>    <span class="nx">worker</span> <span class="nx">State</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span> <span class="c1">// ðŸ‘‰ mgre:TIMESLOT:worker
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">func</span> <span class="nf">newSlotStates</span><span class="p">(</span><span class="nx">slot</span> <span class="nx">Timeslot</span><span class="p">)</span> <span class="o">*</span><span class="nx">SlotStates</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">SlotStates</span><span class="p">{</span>
        <span class="nx">Timeslot</span><span class="p">:</span> <span class="nx">slot</span><span class="p">,</span>
        <span class="nx">status</span><span class="p">:</span> <span class="nf">NewState</span><span class="p">(</span><span class="nx">kStatus</span><span class="p">,</span> <span class="nx">longTTL</span><span class="p">,</span>  <span class="cm">/* ... */</span><span class="p">),</span>
        <span class="nx">worker</span><span class="p">:</span> <span class="nf">NewState</span><span class="p">(</span><span class="nx">kWorker</span><span class="p">,</span> <span class="nx">shortTTL</span><span class="p">,</span> <span class="cm">/* ... */</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>There should be only a single <code>SlotStates</code> for each <code>Timeslot</code> in a pod, shared among manager, keeper, and workers. So it&rsquo;s better to have a centralized place to init and store them:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Migrator</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="nx">slots</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">SlotStates</span>
    <span class="nx">mu</span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">getSlotStates</span><span class="p">(</span><span class="nx">slot</span> <span class="nx">Timeslot</span><span class="p">)</span> <span class="o">*</span><span class="nx">SlotStates</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">_getSlotStates</span><span class="p">();</span> <span class="nx">st</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">st</span> <span class="p">}</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">slots</span><span class="p">[</span><span class="nx">slot</span><span class="p">.</span><span class="nf">String</span><span class="p">()];</span> <span class="nx">st</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">st</span> <span class="p">}</span>
    <span class="nx">st</span> <span class="o">:=</span> <span class="nf">newSlotStates</span><span class="p">(</span><span class="nx">slot</span><span class="p">)</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">slots</span><span class="p">[</span><span class="nx">slot</span><span class="p">.</span><span class="nf">String</span><span class="p">()]</span> <span class="p">=</span> <span class="nx">st</span>
    <span class="k">return</span> <span class="nx">st</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Migrator</span><span class="p">)</span> <span class="nf">_getSlotStates</span><span class="p">()</span> <span class="o">*</span><span class="nx">SlotStates</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">slots</span><span class="p">[</span><span class="nx">slot</span><span class="p">.</span><span class="nf">String</span><span class="p">()]</span>
<span class="p">}</span>
</code></pre></div><hr><h2 id="conclusion">Conclusion</h2><p>Phew! That&rsquo;s a lot!! I&rsquo;m happy that you are still here!</p><p>Migrating large volumes of data in a real-world environment is far more complex than a simple script can handle. By carefully designing and implementing the migration code with partitioning, parallel processing, state management, fault tolerance, idempotency, and centralized progress tracking, we can achieve a reliable migration process, maintain data integrity, and minimize downtime.</p><p>And sleep well at night too! ðŸ˜‹</p><h2 id="author">Author</h2><p>I'm Oliver Nguyen. A software maker working mostly in Go and JavaScript. I enjoy learning and seeing a better version of myself each day. Occasionally spin off new open source projects. Share knowledge and thoughts during my journey. <span>Connect with me on <a class="icon" target="_blank" rel="noopener" href="https://github.com/iOliverNguyen"><i class="fab fa-github"></i> </a>, <a class="icon" target="_blank" rel="noopener" href="https://linkedin.com/in/iOliverNguyen"><i class="fab fa-linkedin"></i> </a>, <a class="icon" target="_blank" rel="noopener" href="https://x.com/_OliverNguyen"><i class="fab fa-twitter"></i> </a>, <a class="icon" target="_blank" rel="noopener" href="https://iOliverNguyen.medium.com"><i class="fab fa-medium-m"></i> </a>and <a class="icon" target="_blank" rel="noopener" href="mailto:iOliverNguyen@gmail.com"><i class="fas fa-envelope"></i> </a>.</span></p></div></article><div id="header-post"><a id="menu-icon" href="/w"><i class="fas fa-chevron-left fa-lg"></i> <span class="icon-text">Back</span></a> <a id="menu-icon-tablet" href="/w"><i class="fas fa-chevron-left fa-lg"></i> <span class="icon-text">Back</span></a></div><div id="footer-post-container"><div id="footer-post"><div id="nav-footer" style="display:none"><ul></ul></div><div id="toc-footer" class="tog-footer" style="display:none"><script>console.log("content",'<nav id="TableOfContents">\n  <ul>\n    <li><a href="#schema">Schema</a></li>\n    <li><a href="#a-naive-approach">A Naive Approach</a></li>\n    <li><a href="#real-world-approach">Real-World Approach</a></li>\n    <li><a href="#architecture">Architecture</a>\n      <ul>\n        <li><a href="#store-states-in-redis">Store States in Redis</a></li>\n        <li><a href="#manager-keepers-and-workers">Manager, Keepers, and Workers</a></li>\n        <li><a href="#retry-mechanism">Retry Mechanism</a></li>\n        <li><a href="#other-notes">Other Notes</a></li>\n      </ul>\n    </li>\n    <li><a href="#implementation">Implementation</a>\n      <ul>\n        <li><a href="#timeslot">Timeslot</a></li>\n        <li><a href="#retry-queries">Retry() Queries</a></li>\n        <li><a href="#states">States</a></li>\n        <li><a href="#slotstates">SlotStates</a></li>\n      </ul>\n    </li>\n    <li><a href="#conclusion">Conclusion</a></li>\n  </ul>\n</nav>')</script><div class="toc-header"><a href="#">Implement a Distributed State Machine with Redis to Migrate Billions of Records</a></div><nav id="TableOfContents"><ul><li><a href="#schema">Schema</a></li><li><a href="#a-naive-approach">A Naive Approach</a></li><li><a href="#real-world-approach">Real-World Approach</a></li><li><a href="#architecture">Architecture</a><ul><li><a href="#store-states-in-redis">Store States in Redis</a></li><li><a href="#manager-keepers-and-workers">Manager, Keepers, and Workers</a></li><li><a href="#retry-mechanism">Retry Mechanism</a></li><li><a href="#other-notes">Other Notes</a></li></ul></li><li><a href="#implementation">Implementation</a><ul><li><a href="#timeslot">Timeslot</a></li><li><a href="#retry-queries">Retry() Queries</a></li><li><a href="#states">States</a></li><li><a href="#slotstates">SlotStates</a></li></ul></li><li><a href="#conclusion">Conclusion</a></li></ul></nav></div><div id="share-footer" class="tog-footer" style="display:none"><ul><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fiOliverNguyen.github.io%2fw%2fmigrate%2f&title=Implement%20a%20Distributed%20State%20Machine%20with%20Redis%20to%20Migrate%20Billions%20of%20Records"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fiOliverNguyen.github.io%2fw%2fmigrate%2f"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://x.com/share?url=https%3a%2f%2fiOliverNguyen.github.io%2fw%2fmigrate%2f&text=Implement%20a%20Distributed%20State%20Machine%20with%20Redis%20to%20Migrate%20Billions%20of%20Records"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2fiOliverNguyen.github.io%2fw%2fmigrate%2f&title=Implement%20a%20Distributed%20State%20Machine%20with%20Redis%20to%20Migrate%20Billions%20of%20Records"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fiOliverNguyen.github.io%2fw%2fmigrate%2f&t=Implement%20a%20Distributed%20State%20Machine%20with%20Redis%20to%20Migrate%20Billions%20of%20Records"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li></ul></div><div id="actions-footer"><a id="home" class="icon" href="/w"><i class="fas fa-chevron-left fa-lg" aria-hidden="true"></i> Back</a> <a id="toc" class="icon" href="#" onclick='return $(".tog-footer").toggle(),!1'><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a> <a id="share" class="icon" href="#" onclick='return $(".tog-footer").toggle(),!1'><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></div></div></div><footer id="footer"><div class="footer-left">Copyright &copy; 2024 Oliver Nguyen.</div><div class="footer-right"><nav><ul></ul></nav></div></footer></div></body><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script src="/lib/jquery/jquery.min.js"></script><script src="/js/main.js"></script></html>