<!doctype html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>My work on the flow compiler for sending campaigns and auto reply | Oliver Nguyen</title><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="robots" content="all,follow"><meta name="googlebot" content="index,follow,snippet,archive"><meta name="og:site_name" content="Oliver Nguyen"><meta property="og:title" content="My work on the flow compiler for sending campaigns and auto reply"><meta property="og:description" content="At work, I&rsquo;m working on the flow compiler, which compile from flow documents into ETA flow descriptors. The use cases are to provide our users the ability to automatically response to their customers&#39; messages. Users can define their own flow and customize auto reply behaviours. This article gives a look into my work. Also see related article.
 Package flow implements the flow document compiler and runtime controller. The compiler is responsible for parsing the flow document and compiling it into a specific format for that flow document type, and can be executed by a runtime engine."><meta property="og:type" content="article"><meta property="og:url" content="https://iOliverNguyen.github.io/w/flow.compiler/"><meta property="og:image" content="https://iOliverNguyen.github.io/images/ogx.png"><meta property="article:section" content="w"><meta property="article:published_time" content="2023-08-10T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-10T00:00:00+00:00"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://iOliverNguyen.github.io/images/ogx.png"><meta name="twitter:title" content="My work on the flow compiler for sending campaigns and auto reply"><meta name="twitter:description" content="At work, I&rsquo;m working on the flow compiler, which compile from flow documents into ETA flow descriptors. The use cases are to provide our users the ability to automatically response to their customers&#39; messages. Users can define their own flow and customize auto reply behaviours. This article gives a look into my work. Also see related article.
 Package flow implements the flow document compiler and runtime controller. The compiler is responsible for parsing the flow document and compiling it into a specific format for that flow document type, and can be executed by a runtime engine."><link rel="stylesheet" href="https://iOliverNguyen.github.io/css/style-classic.css"><link rel="stylesheet" href="https://iOliverNguyen.github.io/style.css"><link rel="icon" type="image/png" href="/images/favicon.png"><link href="https://iOliverNguyen.github.io/w/flow.compiler/index.xml" rel="alternate" type="application/rss+xml" title="Oliver Nguyen"><script async src="https://www.googletagmanager.com/gtag/js?id=G-L5X8RJDCLM"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-L5X8RJDCLM")</script><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></head><body class="max-width mx-auto px3 ltr"><div class="content index py4"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">My work on the flow compiler for sending campaigns and auto reply</h1><div class="meta"><div class="postdate"><time datetime="2023-08-10 00:00:00 &#43;0000 UTC" itemprop="datePublished">2023-08-10</time></div><div class="article-tag">&nbsp;· <a class="tag-link" href="/w/#work" rel="tag">work</a></div></div></header><div class="content" itemprop="articleBody"><p><em>At work, I&rsquo;m working on the flow compiler, which compile from flow documents into ETA flow descriptors. The use cases are to provide our users the ability to automatically response to their customers' messages. Users can define their own flow and customize auto reply behaviours. This article gives a look into my work. Also see related <a href="../flow.doc">article</a>.</em></p><hr><p>Package <em>flow</em> implements the flow document compiler and runtime controller. The compiler is responsible for parsing the flow document and compiling it into a specific format for that flow document type, and can be executed by a runtime engine. Currently, there are two compiler engines: auto reply and campaign. The compilation process is divided into five phases: scanner, parser, analyzer, generating ir, and generating output.</p><h2 id="package-structure">Package Structure</h2><p><strong>List of compiler engines:</strong></p><ul><li><em>AutoReply</em>: Compile flow documents with type <em>AUTO_REPLY</em> to <code>*etapb.FlowDescriptor</code>. Use case: to reply automatically to customer messages.</li><li><em>Campaign</em>: Compile flow document with type <em>SENDOUT</em> to <code>*etapb.FlowDescriptor</code> and campaign configuration. Use case: to send out messages to customers and reply to their responses.</li></ul><p><strong>The general structure:</strong></p><ul><li><em>compiler</em>: Contains the generic compiler infrastructure implementation, which can be shared by different compiler engines.</li><li><em>compilers</em>: Contains the compiler engines implementation, which is responsible for compiling each type of flow documents into specific formats.</li><li><em>registry</em>: Contains the registry implementation, which is responsible for registering different type of objects for the purposes of scanner, parser, analyzer, and different compiler engines.</li><li><em>objects</em>: Provides the objects which are used by the compiler engines, and their customized behaviors. Each document type has its own list of available objects. They are grouped by document type and registered in the registry.</li></ul><p><strong>The structure of shared packages:</strong></p><ul><li><em>compiler/diagnostics</em>: The diagnostic implementation, which is a list of errors, warnings, and notes. These diagnostics can be produced by any step of the compilers.</li><li><em>compiler/syntax</em>: Provide the tokens in form of syntax.TypedFlowObject and ast in form of syntax.Node and syntax.Edge interfaces.</li><li><em>compiler/scanner</em>: The lexer implementation, which receives a flow document and produces syntax.TypedFlowDocument.</li><li><em>compiler/parser</em>: The parser implementation, which receives a syntax.TypedFlowDocument and produces syntax.ParsedFlowDocument.</li><li><em>compiler/dependency</em>: The dependency resolver implementation, dependency.Resolver, which is an interface that can be used to resolve dependencies in compiler engines and mocked in tests.</li><li><em>compiler/analyzer</em>: The static and dependency analyzer implementation, which executes on syntax.ParsedFlowDocument and dependency.Resolver.</li></ul><p><strong>The structure of each compiler engine:</strong></p><ul><li><em>ir</em>: The intermediate representation of the flow document, which is used by the compiler engine during the compilation. engine: The engine implementation, which is responsible for compiling the flow document into a specific format for that flow document type and runtime engine.</li><li><em>cctx</em>: The context and state using during the compilation, which includes the logger, the diagnostic, dependency resolver, and the intermediate representation.</li></ul><p><strong>Importing constraints:</strong></p><ul><li><em>compiler</em>: The innermost layer. Can NOT import any other layers.</li><li><em>registry</em>: Can import compiler.</li><li><em>compilers</em>: Can import registry and compiler packages. Each compiler engine must NOT import other compiler engines’ code.</li><li><em>objects</em>: The outtermost layer. Can import registry, compiler, and compilers packages.</li></ul><h2 id="token">Token</h2><p>The flow document protobuf is first parsed into a <code>syntax.TypedFlowDocument</code>, which is a list of <code>syntax.TypedFlowObject</code>. Each <code>syntax.TypedFlowObject</code> is a token, which is a struct with id, type and value for that specific object type. The value is parsed into a specific typed protobuf message grouping under an oneof. From that value, we can access the property and data for that specific object type.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">syntax</span>

<span class="kd">type</span> <span class="nx">TypedFlowObject</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ID</span>    <span class="nx">uuid</span><span class="p">.</span><span class="nx">ID</span>
	<span class="nx">Type</span>  <span class="nx">FlowObjectType</span>
	<span class="nx">Model</span> <span class="kd">struct</span> <span class="p">{</span> <span class="c1">// oneof
</span><span class="c1"></span>		<span class="nx">SimpleEdge</span> <span class="kd">struct</span> <span class="p">{</span>
			<span class="nx">Source</span> <span class="kt">string</span>
			<span class="nx">Target</span> <span class="kt">string</span>
			<span class="nx">Data</span>   <span class="nx">SimpleEdgeData</span>
		<span class="p">}</span>
		<span class="nx">CustomAutoReply</span>   <span class="kd">struct</span><span class="p">{}</span>
		<span class="nx">IncomingRoomEvent</span> <span class="kd">struct</span><span class="p">{}</span>
		<span class="nx">SendWaMessage</span>     <span class="kd">struct</span><span class="p">{}</span>
		<span class="c1">// ...
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Package <em>scanner</em> implement the Scan function, which receives a flow document and produces a <code>syntax.TypedFlowDocument</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">scanner</span>

<span class="kd">func</span> <span class="nf">Scan</span><span class="p">(</span><span class="nx">diag</span> <span class="o">*</span><span class="nx">diagx</span><span class="p">.</span><span class="nx">Result</span><span class="p">,</span> <span class="nx">doc</span> <span class="o">*</span><span class="nx">flowpb</span><span class="p">.</span><span class="nx">FlowDocument</span><span class="p">)</span> <span class="p">(</span><span class="nx">out</span> <span class="o">*</span><span class="nx">syntax</span><span class="p">.</span><span class="nx">TypedFlowDocument</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">syntax</span>

<span class="kd">type</span> <span class="nx">TypedFlowDocument</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">FlowDoc</span>      <span class="o">*</span><span class="nx">flowpb</span><span class="p">.</span><span class="nx">FlowDocument</span>
	<span class="nx">ObjByID</span>      <span class="kd">map</span><span class="p">[</span><span class="nx">uuid</span><span class="p">.</span><span class="nx">UUID</span><span class="p">]</span><span class="o">*</span><span class="nx">flowpb</span><span class="p">.</span><span class="nx">FlowObject</span>
	<span class="nx">TypedObjByID</span> <span class="kd">map</span><span class="p">[</span><span class="nx">uuid</span><span class="p">.</span><span class="nx">UUID</span><span class="p">]</span><span class="o">*</span><span class="nx">TypedFlowObject</span>
	<span class="nx">PropByObjID</span>  <span class="kd">map</span><span class="p">[</span><span class="nx">uuid</span><span class="p">.</span><span class="nx">UUID</span><span class="p">][]</span><span class="o">*</span><span class="nx">flowpb</span><span class="p">.</span><span class="nx">FlowObjectProperty</span>
	<span class="nx">PropByKey</span>    <span class="kd">map</span><span class="p">[</span><span class="nx">Position</span><span class="p">]</span><span class="o">*</span><span class="nx">flowpb</span><span class="p">.</span><span class="nx">FlowObjectProperty</span>
<span class="p">}</span>
</code></pre></div><h2 id="ast">AST</h2><p>The <code>syntax.TypedFlowDocument</code> is then parsed into a <code>syntax.ParsedFlowDocument</code>, which is a list of <code>syntax.Node</code> and <code>syntax.Edge</code> interface. They are the abstract syntax tree (AST) of the flow document. The <code>syntax.Node</code> interface represents a node in the flow document. It contains the id, type, and the list of incoming and outgoing edges. It also reports whether it is visited or not so the compiler engine can decide to create a new event/action or trigger a previous action.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">syntax</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">GetID</span><span class="p">()</span> <span class="nx">uuid</span><span class="p">.</span><span class="nx">UUID</span>
	<span class="nf">GetType</span><span class="p">()</span> <span class="nx">flowpb</span><span class="p">.</span><span class="nx">FlowObjectType</span>
	<span class="nf">GetCore</span><span class="p">()</span> <span class="o">*</span><span class="nx">NodeCore</span>
	<span class="nf">GetTypedFlowObject</span><span class="p">()</span> <span class="o">*</span><span class="nx">TypedFlowObject</span>
	<span class="nf">GetVisited</span><span class="p">()</span> <span class="kt">bool</span>
	<span class="nf">GetIncomingEdges</span><span class="p">()</span> <span class="p">[]</span><span class="nx">Edge</span>
	<span class="nf">GetOutgoingEdges</span><span class="p">()</span> <span class="p">[]</span><span class="nx">Edge</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">NodeCore</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">TypedFlowObject</span>

	<span class="nx">Visited</span>       <span class="kt">bool</span>
	<span class="nx">IncomingEdges</span> <span class="p">[]</span><span class="nx">Edge</span>
	<span class="nx">OutgoingEdges</span> <span class="p">[]</span><span class="nx">Edge</span>
<span class="p">}</span>
</code></pre></div><p>The <code>syntax.Edge</code> interface represents an edge in the flow document. It connects two nodes in a direction from source node to target node. A syntax.Node can have multiple incoming and outgoing edges. Each outgoing <code>syntax.Edge</code> can have different source handle and target handle to indicate what should happen by that edge. For example, an edge trigger after a <code>SendWaMessage</code> action node, with the source handle is <code>button-click:1</code> to indicate that this edge should be followed when the customer clicks the first button in that template or interaction message.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">syntax</span>

<span class="kd">type</span> <span class="nx">Edge</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">GetID</span><span class="p">()</span> <span class="nx">uuid</span><span class="p">.</span><span class="nx">UUID</span>
	<span class="nf">GetType</span><span class="p">()</span> <span class="nx">flowpb</span><span class="p">.</span><span class="nx">FlowObjectType</span>
	<span class="nf">GetCore</span><span class="p">()</span> <span class="o">*</span><span class="nx">EdgeCore</span>
	<span class="nf">GetTypedFlowObject</span><span class="p">()</span> <span class="o">*</span><span class="nx">TypedFlowObject</span>
	<span class="nf">GetSourceID</span><span class="p">()</span> <span class="nx">uuid</span><span class="p">.</span><span class="nx">UUID</span>
	<span class="nf">GetTargetID</span><span class="p">()</span> <span class="nx">uuid</span><span class="p">.</span><span class="nx">UUID</span>
	<span class="nf">GetSrcHandle</span><span class="p">()</span> <span class="kt">string</span>
	<span class="nf">GetTgtHandle</span><span class="p">()</span> <span class="kt">string</span>
	<span class="nf">GetStartNode</span><span class="p">()</span> <span class="nx">Node</span>
	<span class="nf">GetEndNode</span><span class="p">()</span> <span class="nx">Node</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">EdgeCore</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">TypedFlowObject</span> <span class="c1">// simple edge
</span><span class="c1"></span>
	<span class="nx">SourceID</span>  <span class="nx">uuid</span><span class="p">.</span><span class="nx">UUID</span>
	<span class="nx">TargetID</span>  <span class="nx">uuid</span><span class="p">.</span><span class="nx">UUID</span>
	<span class="nx">SrcHandle</span> <span class="kt">string</span> <span class="c1">// prefix trimmed
</span><span class="c1"></span>	<span class="nx">TgtHandle</span> <span class="kt">string</span> <span class="c1">// prefix trimmed
</span><span class="c1"></span>
	<span class="nx">StartNode</span> <span class="nx">Node</span>
	<span class="nx">EndNode</span>   <span class="nx">Node</span>
<span class="p">}</span>

</code></pre></div><p>The <code>syntax.Node</code> interface are extended by <code>registry.Node</code> interface, which adds a few additional interfaces to help scanner initialize the node or analyzer validate the node type. It is extended further by <code>autoreply.Node</code> interface which packs the <code>AutoReplyKind()</code> method together to indicate the kind of the node. It is then extended again by <code>autoreply.EventNode</code> and <code>autoreply.ActionNode</code> interfaces to provide additional behavior code for each kind of node: start, event, or action.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">registry</span>

<span class="kd">type</span> <span class="nx">Object</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">scanner</span><span class="p">.</span><span class="nx">ObjectInitializer</span>
	<span class="nx">analyzer</span><span class="p">.</span><span class="nx">ObjectValidator</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Object</span>
	<span class="nx">syntax</span><span class="p">.</span><span class="nx">Node</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">autoreply</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">registry</span><span class="p">.</span><span class="nx">Node</span>
	<span class="nf">AutoReplyKind</span><span class="p">()</span> <span class="nx">ir</span><span class="p">.</span><span class="nx">AutoReplyKind</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">EventNode</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Node</span>
	<span class="nf">ProcessEvent</span><span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">cctx</span><span class="p">.</span><span class="nx">CompilationContext</span><span class="p">,</span> <span class="nx">branch</span> <span class="o">*</span><span class="nx">ir</span><span class="p">.</span><span class="nx">Branch</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">etapb</span><span class="p">.</span><span class="nx">EventDescriptor</span><span class="p">,</span> <span class="o">*</span><span class="nx">ir</span><span class="p">.</span><span class="nx">AvailableBranches</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ActionNode</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Node</span>
	<span class="nf">ProcessAction</span><span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">cctx</span><span class="p">.</span><span class="nx">CompilationContext</span><span class="p">,</span> <span class="nx">branch</span> <span class="o">*</span><span class="nx">ir</span><span class="p">.</span><span class="nx">Branch</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">etapb</span><span class="p">.</span><span class="nx">ActionDescriptor</span><span class="p">,</span> <span class="o">*</span><span class="nx">ir</span><span class="p">.</span><span class="nx">AvailableBranches</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>Package <em>parser</em> implements the Parse function, which receives a <code>syntax.TypedFlowDocument</code> and produces a <code>syntax.ParsedFlowDocument</code>, which is a list of <code>syntax.Node</code> and <code>syntax.Edge</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">parser</span>

<span class="kd">func</span> <span class="nf">Parse</span><span class="p">(</span><span class="nx">diag</span> <span class="o">*</span><span class="nx">diagx</span><span class="p">.</span><span class="nx">Result</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">syntax</span><span class="p">.</span><span class="nx">TypedFlowDocument</span><span class="p">)</span> <span class="o">*</span><span class="nx">syntax</span><span class="p">.</span><span class="nx">ParsedFlowDocument</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">syntax</span>

<span class="kd">type</span> <span class="nx">ParsedFlowDocument</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Root</span>  <span class="nx">Node</span>
	<span class="nx">Nodes</span> <span class="p">[]</span><span class="nx">Node</span>
	<span class="nx">Edges</span> <span class="p">[]</span><span class="nx">Edge</span>
<span class="p">}</span>
</code></pre></div><h2 id="ir">IR</h2><p>Each compiler engine implements its own set of intermediate representation (IR) for supporting the compilation process. The auto reply engine implements the following IR in the package <em>compilers/autoreply/ir</em>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">ir</span>

<span class="kd">type</span> <span class="nx">Document</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Root</span> <span class="o">*</span><span class="nx">Branch</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Branch</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Edge</span> <span class="nx">syntax</span><span class="p">.</span><span class="nx">Edge</span>

	<span class="nx">Event</span>         <span class="nx">Event</span>
	<span class="nx">Trigger</span>       <span class="nx">Trigger</span>
	<span class="nx">Action</span>        <span class="nx">Action</span>
	<span class="nx">GotoBranch</span>    <span class="o">*</span><span class="nx">Branch</span>
	<span class="nx">TriggerBranch</span> <span class="o">*</span><span class="nx">Branch</span>
	<span class="nx">Branches</span>      <span class="p">[]</span><span class="o">*</span><span class="nx">Branch</span>
<span class="p">}</span>
</code></pre></div><p>The <code>ir.Branch</code> type is the main IR type for the auto reply engine. It represents a branch in the output ETA. Each branch may be a single edge or multiple edge starting from a trigger (start node or template/interactive send wa message action node) going through an event node and arriving at another action node. The main job of the compilation engine is to convert the <code>syntax.ParsedFlowDocument</code> into a ir.Document and then convert the <code>ir.Document</code> into an ETA descriptor, the final output.</p><h2 id="object-registry">Object registry</h2><p>Each phase of the compilation process produces a list of various types of objects implements a specific interface. For example, the scanner produces a list of <code>syntax.TypedFlowObject</code> which can be <code>SimpleEdge</code>, <code>CustomAutoReply</code>, or <code>IncomingRoomEvent</code>, etc. The parser produces a list of <code>syntax.Node</code> which can be <code>CustomAutoReply</code>, <code>IncomingRoomEvent</code>, or <code>SendWaMessage</code>, etc. And each type of document has a different set of available building blocks. For example, the auto reply document uses <code>CustomAutoReply</code> while the campaign document uses <code>CustomSendCampaign</code>. Therefore, the <em>registry</em> package is required to keep track of all the available building blocks for each type of document and provide a way to initialize and validate them.</p><p>The <code>scanner.ObjectInitializer</code> interface is used to initialize the <code>syntax.TypedFlowObject</code> with various types. The initializer prepares a container <code>proto.Message</code> of the correct type to be fed to the scanner:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">registry</span>

<span class="kd">type</span> <span class="nx">ObjectInitializer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">InitTypedFlowObject</span><span class="p">(</span><span class="nx">out</span> <span class="o">*</span><span class="nx">syntax</span><span class="p">.</span><span class="nx">TypedFlowObject</span><span class="p">)</span> <span class="nx">proto</span><span class="p">.</span><span class="nx">Message</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">RegisterObjectInitializer</span><span class="p">(</span><span class="nx">typ</span> <span class="nx">flowpb</span><span class="p">.</span><span class="nx">FlowObjectType</span><span class="p">,</span> <span class="nx">initializer</span> <span class="nx">ObjectInitializer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">objectInitializers</span><span class="p">[</span><span class="nx">typ</span><span class="p">]</span> <span class="p">=</span> <span class="nx">initializer</span>
<span class="p">}</span>
</code></pre></div><p>The <code>parser.DocumentClassifier</code> interface is used to provide each the flow document type a set of available building blocks. And each building block implements <code>parser.ObjectConstructor</code> interface to be used by the parser to create the specific <code>syntax.Node</code> and syntax.Edge implementation. For example, the <code>NewNode()</code> method of the incoming room event implementation of parser.ObjectConstructor may receive a <code>syntax.NodeCore</code> with type <code>FLOW_OBJECT_TYPE_INCOMING_ROOM_EVENT</code> and return an <code>incoming_room_event.IncomingRoomEvent</code> event node wrapping around that core:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">registry</span>

<span class="kd">type</span> <span class="nx">DocumentClassifier</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Category</span><span class="p">()</span> <span class="nx">flowpb</span><span class="p">.</span><span class="nx">FlowDocumentCategory</span>
	<span class="nf">DocumentType</span><span class="p">()</span> <span class="nx">flowpb</span><span class="p">.</span><span class="nx">FlowDocumentType</span>
	<span class="nf">StartNodeType</span><span class="p">()</span> <span class="nx">flowpb</span><span class="p">.</span><span class="nx">FlowObjectType</span>
	<span class="nf">AcceptNodeType</span><span class="p">(</span><span class="nx">flowpb</span><span class="p">.</span><span class="nx">FlowObjectType</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ObjectConstructor</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">IsEdge</span><span class="p">()</span> <span class="kt">bool</span>
	<span class="nf">NewEdge</span><span class="p">(</span><span class="o">*</span><span class="nx">syntax</span><span class="p">.</span><span class="nx">EdgeCore</span><span class="p">)</span> <span class="nx">syntax</span><span class="p">.</span><span class="nx">Edge</span>
	<span class="nf">NewNode</span><span class="p">(</span><span class="o">*</span><span class="nx">syntax</span><span class="p">.</span><span class="nx">NodeCore</span><span class="p">)</span> <span class="nx">syntax</span><span class="p">.</span><span class="nx">Node</span>
<span class="p">}</span>
</code></pre></div><p>Each compiler engine provides its own node classifier to further separate the kind of its own node types. For example, the auto reply engine provides the following node classifier:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">autoreply</span>

<span class="kd">func</span> <span class="nf">ValidateNodeClassifier</span><span class="p">(</span><span class="nx">sample</span> <span class="nx">syntax</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">kindGetter</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">sample</span><span class="p">.(</span><span class="nx">Node</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Newf</span><span class="p">(</span><span class="s">&#34;node %T does not implement autoreply.KindGetter&#34;</span><span class="p">,</span> <span class="nx">sample</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">switch</span> <span class="nx">kindGetter</span><span class="p">.</span><span class="nf">AutoReplyKind</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">ir</span><span class="p">.</span><span class="nx">KindStart</span><span class="p">:</span>
    <span class="c1">// nothing
</span><span class="c1"></span>  <span class="k">case</span> <span class="nx">ir</span><span class="p">.</span><span class="nx">KindEvent</span><span class="p">:</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">sample</span><span class="p">.(</span><span class="nx">EventNode</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Newf</span><span class="p">(</span><span class="s">&#34;event node %T does not implement autoreply.EventNode&#34;</span><span class="p">,</span> <span class="nx">sample</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="k">case</span> <span class="nx">ir</span><span class="p">.</span><span class="nx">KindAction</span><span class="p">:</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">sample</span><span class="p">.(</span><span class="nx">ActionNode</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Newf</span><span class="p">(</span><span class="s">&#34;action node %T does not implement autoreply.ActionNode&#34;</span><span class="p">,</span> <span class="nx">sample</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>The <em>registry</em> packages take care of registering the available building blocks for each type of document, feeding the <em>scanner</em> and <em>parser</em> package the corresponding initializers and constructors they need. This help keep the scanner and parser code clean without worrying about the details of each type of document or object. The autoreply engine can cast the <code>syntax.Node</code> into <code>autoreply.EventNode</code> or <code>autoreply.ActionNode</code> to access the specific methods it needs for that kind of object.</p><h2 id="author">Author</h2><p>I'm Oliver Nguyen. A software maker working mostly in Go and JavaScript. I enjoy learning and seeing a better version of myself each day. Occasionally spin off new open source projects. Share knowledge and thoughts during my journey. <span>Connect with me on <a class="icon" target="_blank" rel="noopener" href="https://github.com/iOliverNguyen"><i class="fab fa-github"></i> </a>, <a class="icon" target="_blank" rel="noopener" href="https://linkedin.com/in/iOliverNguyen"><i class="fab fa-linkedin"></i> </a>, <a class="icon" target="_blank" rel="noopener" href="https://x.com/_OliverNguyen"><i class="fab fa-twitter"></i> </a>, <a class="icon" target="_blank" rel="noopener" href="https://iOliverNguyen.medium.com"><i class="fab fa-medium-m"></i> </a>and <a class="icon" target="_blank" rel="noopener" href="mailto:iOliverNguyen@gmail.com"><i class="fas fa-envelope"></i> </a>.</span></p></div></article><div id="header-post"><a id="menu-icon" href="/w"><i class="fas fa-chevron-left fa-lg"></i> <span class="icon-text">Back</span></a> <a id="menu-icon-tablet" href="/w"><i class="fas fa-chevron-left fa-lg"></i> <span class="icon-text">Back</span></a></div><div id="footer-post-container"><div id="footer-post"><div id="nav-footer" style="display:none"><ul></ul></div><div id="toc-footer" class="tog-footer" style="display:none"><script>console.log("content",'<nav id="TableOfContents">\n  <ul>\n    <li><a href="#package-structure">Package Structure</a></li>\n    <li><a href="#token">Token</a></li>\n    <li><a href="#ast">AST</a></li>\n    <li><a href="#ir">IR</a></li>\n    <li><a href="#object-registry">Object registry</a></li>\n  </ul>\n</nav>')</script><div class="toc-header"><a href="#">My work on the flow compiler for sending campaigns and auto reply</a></div><nav id="TableOfContents"><ul><li><a href="#package-structure">Package Structure</a></li><li><a href="#token">Token</a></li><li><a href="#ast">AST</a></li><li><a href="#ir">IR</a></li><li><a href="#object-registry">Object registry</a></li></ul></nav></div><div id="share-footer" class="tog-footer" style="display:none"><ul><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fiOliverNguyen.github.io%2fw%2fflow.compiler%2f&title=My%20work%20on%20the%20flow%20compiler%20for%20sending%20campaigns%20and%20auto%20reply"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fiOliverNguyen.github.io%2fw%2fflow.compiler%2f"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://x.com/share?url=https%3a%2f%2fiOliverNguyen.github.io%2fw%2fflow.compiler%2f&text=My%20work%20on%20the%20flow%20compiler%20for%20sending%20campaigns%20and%20auto%20reply"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2fiOliverNguyen.github.io%2fw%2fflow.compiler%2f&title=My%20work%20on%20the%20flow%20compiler%20for%20sending%20campaigns%20and%20auto%20reply"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fiOliverNguyen.github.io%2fw%2fflow.compiler%2f&t=My%20work%20on%20the%20flow%20compiler%20for%20sending%20campaigns%20and%20auto%20reply"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li></ul></div><div id="actions-footer"><a id="home" class="icon" href="/w"><i class="fas fa-chevron-left fa-lg" aria-hidden="true"></i> Back</a> <a id="toc" class="icon" href="#" onclick='return $(".tog-footer").toggle(),!1'><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a> <a id="share" class="icon" href="#" onclick='return $(".tog-footer").toggle(),!1'><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></div></div></div><footer id="footer"><div class="footer-left">Copyright &copy; 2024 Oliver Nguyen.</div><div class="footer-right"><nav><ul></ul></nav></div></footer></div></body><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script src="/lib/jquery/jquery.min.js"></script><script src="/js/main.js"></script></html>